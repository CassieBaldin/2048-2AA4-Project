\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}
\usepackage{hyperref}

\oddsidemargin -10mm
\evensidemargin -10mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Assignment 4 Specification}
\author{SFWR ENG 2AA4}

\begin {document}

\maketitle
This Module Interface Specification (MIS) document contains modules, types and
methods used to support the CEAB (Canadian Engineering Accreditation Board)
graduate attributes process.  An accredited program needs to measure the
learning outcomes in all of the courses and show that the measures adequately
satisfy the graduate attributes specified by the CEAB.

For every learning outcome in every course in a given program the number of
students is counted in each of the following categories: below expectations,
marginal, meets expectations and exceeds expectations.  This data for each
learning outcome needs to be aggregated to express the results using the CEAB's
graduate attributes.  We will use the same categories when summarizing the
attributes, but rather than using student numbers, below, marginal, meets and
exceeds will be expressed as percentages.

Each attribute is divided into a set of indicators.  Each program consists of a
set of courses and each course will cover a set of indicators.  For each
indicator in a course there will be a set of learning outcomes.  The learning
outcomes are course specific, but the indicators and the attributes are
determined by the CEAB and the Faculty of Engineering, respectively.

There are many choices on how to aggregate the data, depending on at what point
the data is normalized.  These modules allow this choice to be modified at
run-time so that the different possibilities can be dynamically explored.  This
is enabled by the use of the Norm abstract object module.  At one extreme the
data for a program is only normalized after summing all of the student counts
for each learning outcome for each indicator for each attribute in each course.
At the other extreme all of the data is normalized at each step, starting with
the measures of the learning outcomes themselves.  A comparison of the different
schemes can be found in the
\href{https://gitlab.cas.mcmaster.ca/smiths/se2aa4_cs2me3/-/blob/master/Assignments/A3/AggregationStrategies.xlsx}
{sample spreadsheet} available in the assignment folder.

% In applying the specification, there may be cases that involve undefinedness.
% We will interpret undefinedness following~\cite{Farmer2004}:

% If $p: \alpha_1 \times .... \times \alpha_n \rightarrow \mathbb{B}$ and any of
% $a_1, ..., a_n$ is undefined, then $p(a_1, ..., a_n)$ is False.  For instance,
% if $p(x) = 1/x < 1$, then $p(0) = \text{False}$.  In the language of our
% specification, if evaluating an expression generates an exception, then the
% value of the expression is undefined.

% \wss{The parts that you need to fill in are marked by comments, like this one.
%   In several of the modules local functions are specified.  You can use these
%   local functions to complete the missing specifications.}

% \wss{As you edit the tex source, please leave the \texttt{wss} comments in the
%   file.  Put your answer \textbf{after} the comment.  This will make grading
%   easier.}

% \bibliographystyle{plain}
% \bibliography{SmithCollectedRefs}

\newpage

\section* {SetUp Module}

\subsection*{Template Module}

SetUp

\subsection* {Uses}

None

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

SetUp = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new SetUp & & & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$\mathit{game\_board}: \text{grid}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

None

\subsubsection* {Access Routine Semantics}

\noindent new SetUp():
\begin{itemize}
\item transition: game\_board(random\_spot() = random\_num()), such that there are two unique cells filled once the transition is finished. 
\item output: $out := none$
\item exception: none
\end{itemize}

\noindent get\_board():
\begin{itemize}
\item output: $out := \mathit{gameboard}$
\item exception: none
\end{itemize}

\subsection*{Local Functions}

\noindent random\_num: \text{none} \rightarrow $\mathbb{N}$\\
\noindent $\mbox{random\_num}() \equiv \text{num} $
\textit{\# Where num is a random number such that a 2 is 90 percent likely, and 4 is 10 percent likely to occur} ~\\

\noindent random\_entry: \text{none} \rightarrow \text{seq of } $\mathbb{N}$\\
\noindent $\mbox{random\_entry}() \equiv \text{cell} $
\textit{\# Where cell is a random set of coordinates from a grid where each space in the grid is equally likely}$\\

\newpage

\section* {Score (Abstract Object)}

\subsection*{Module}

Score

\subsection* {Uses}

None

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

Score = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
  \hline
  \textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
  \hline
  set\_score & $\mathbb{N}$ & & & \\
  \hline
  get\_score & & $\mathbb{N}$ & \\
  \hline
  reset\_score & & & \\
  \hline
  
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$\mathit{score}$: $\mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The state variable will be set to zero (to start new score for game) before it is modified. 

\subsubsection* {Access Routine Semantics}

\noindent set\_score($\mathit{s}$):
\begin{itemize}
\item transition: $\mathit{score} := \mathit{s}$
\item exception: none
\end{itemize}

\noindent get\_score( ):
\begin{itemize}
\item output: $out := \mathit{score}$
\item exception: none
\end{itemize}

\noindent reset\_score():
\begin{itemize}
\item transition: $\mathit{score} := 0$
\item out: none
\item exception: none
\end{itemize}

\newpage

\section* {View Module}

\subsection* {Module}

View

\subsection* {Uses}

None

\subsection* {Syntax}

\subsubsection* {Exported Types}

View = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new View & $\text{grid of } \mathbb{N})$ & & \\
\hline

\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

None

\subsubsection* {Access Routine Semantics}

\noindent View(game\_board)

\begin{itemize}
\item transition: print to console the current score (using Score abstract object) and the current state of the board

\newpage

\section* {Board}

\subsection*{Module}

Board

\subsection* {Uses}

SetUp, View, Move

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

Board = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
  \hline
  \textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
  \hline
  start & & & & \\
  \hline
  view & & & \\
  \hline
  move & String & & \\
  \hline
  
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$\mathit{game\_board}$: $\text{grid of } \mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

Move input (direction) assumed to be only "wasd" characters. 

\subsubsection* {Access Routine Semantics}

\noindent start( ):
\begin{itemize}
\item transition: $\mathit{game\_board} := \mathit{SetUp.get\_board()}$
\item out: none
\item exception: none
\end{itemize}

\noindent view( ):
\begin{itemize}
\item transition: \textit{\# New instance of View(game\_board) to show player the state of the board}$\\
\item exception: none
\end{itemize}

\noindent move( ):
\begin{itemize}
\item transition: \textit{\# New instance of Move(game\_board)}$\\

$(\langle direction = "w" \rightarrow Move.up() | direction = "s" \rightarrow Move.down() | direction = "a" \rightarrow Move.left() | True \rightarrow Move.right()) \rangle$

\item exception: none
\end{itemize}

\newpage

\section* {Move}

\subsection*{Module}

Move

\subsection* {Uses}

None

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

Move = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
  \hline
  \textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
  \hline
  new Move & $\text{grid of } \mathbb{N})$ & & \\
  \hline
  up & & & \\
  \hline
  down & & & \\
  \hline
  left & & & \\
  \hline
  right & & & \\
  \hline
  
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$\mathit{game\_board}$: $\text{grid of } \mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

Assumes the Board object that the Move class will be used in will be set up first before engaging in a move.  

\subsubsection* {Access Routine Semantics}

\noindent Move(board):
\begin{itemize}
\item transition: $\mathit{game\_board} := \mathit{board}$
\item out: none
\item exception: none
\end{itemize}

\noindent up( ):
\begin{itemize}
% NEED TO CHANGE INTO MATH
\item transition: \textit{\# Loop through board starting at second highest row and work towards last row. Check if cell above current cell has same value, if so merge(current, above cell). If cell above current cell is $0$, make above cell value the value of the current cell, current cell value now empty. Then after all cells have been shifted, add\_new\_block to game\_board} ~\\
\item exception: none
\end{itemize}

\noindent down( ):
\begin{itemize}
% NEED TO CHANGE INTO MATH
\item transition: \textit{\# Loop through board starting at second lowest row and work towards first row. Check if cell below current cell has same value, if so merge(current, below cell). If cell below current cell is $0$, make below cell value the value of the current cell, current cell value now empty. Then after all cells have been shifted, add\_new\_block to game\_board} ~\\
\item exception: none
\end{itemize}

\noindent left( ):
\begin{itemize}
% NEED TO CHANGE INTO MATH
\item transition: \textit{\# Loop through board starting at second leftmost row and work towards rightmost row. Check if cell to left of current cell has same value, if so merge(current, left cell). If cell left of current cell is $0$, make left cell value the value of the current cell, current cell value now empty. Then after all cells have been shifted, add\_new\_block to game\_board} ~\\
\item exception: none
\end{itemize}

\noindent right( ):
\begin{itemize}
% NEED TO CHANGE INTO MATH
\item transition: \textit{\# Loop through board starting at second rightmost row and work towards leftmost row. Check if cell to right of current cell has same value, if so merge(current, right cell). If cell right of current cell is $0$, make right cell value the value of the current cell, current cell value now empty. Then after all cells have been shifted, add\_new\_block to game\_board} ~\\
\item exception: none
\end{itemize}

\subsection*{Local Functions}

\noindent merge: \text{seq of } $\mathbb{N}, \text{seq of } $\mathbb{N} \rightarrow none \\
\noindent $\mbox{merge}(cell1, cell2) \equiv \text{merge} $
\textit{\# Where merge changes the cell1 to a value of $0$, and doubles the value of cell2, while adding the value in cell2 to the Score abstract object} ~\\

\noindent add\_new\_block: none \rightarrow none \\
\noindent $\mbox{add\_new\_block}() \equiv \text{add} $
\textit{\# Where add adds another random number in a random empty spot on the game board} ~\\

\noindent random\_num: \text{none} \rightarrow $\mathbb{N}$\\
\noindent $\mbox{random\_num}() \equiv \text{num} $
\textit{\# Where num is a random number such that a 2 is 90 percent likely, and 4 is 10 percent likely to occur} ~\\

\noindent random\_entry: \text{none} \rightarrow \text{seq of } $\mathbb{N}$\\
\noindent $\mbox{random\_entry}() \equiv \text{cell} $
\textit{\# Where cell is a random set of coordinates from a grid where each space in the grid is equally likely}$\\

\end {document}
