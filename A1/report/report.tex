\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 1 Solution}
\author{Cassidy Baldin, baldic1}
\date{\today}

\begin {document}

\maketitle

This report discusses testing of the \verb|ComplexT| and \verb|TriangleT|
classes written for Assignment 1. It also discusses testing of the partner's
version of the two classes. The design restrictions for the assignment
are critiqued and then various related discussion questions are answered.

\section{Assumptions and Exceptions} \label{AssumptAndExcept}

No exceptions were thrown in this assignment, but some assumptions were made 
in the process of making these classes written for this assignment. These 
assumptions are made in the code where applicable, which can also be seen below as:
\begin{itemize}
        \item Input values passed to the \verb|ComplexT| constructor, were 
        assumed to be of type \verb|float|, and that both input parameters 
        would not be equal to 0 simultaneously (input will never be z = 0 + 0i),
        \item Return values of \verb|get_phi| were assumed to be in the range 
        of (-pi, pi],
        \item Input values for method \verb|equal| in class \verb|ComplexT| is 
        of type \verb|ComplexT|, and values are considered to be equal if both 
        the real and imaginary values of the argument are equal to the current 
        real and imaginary values respectively (within 9 decimal places),
        \item Return value of \verb|conj|, \verb|add|, \verb|sub|, \verb|mult|, 
        \verb|recip|, \verb|div| and \verb|sqrt| is a new ComplexT that is 
        equal to the result of their respective methods,
        \item Return value of \verb|sqrt| is only the positive part of the square 
        root of the current object, 
        \item Input values passed to the \verb|TriangleT| constructor, were 
        assumed to be positive, non-zero integer values (to relate to the real 
        world application of triangle dimensions),
        \item Input values for method \verb|equal| in class \verb|TriangleT| is 
        of type \verb|TriangleT|, and values are considered to be equal all side 
        lengths are equal (within 9 decimal places),
        \item Input value for method \verb|area| is a valid triangle so that the 
        area can actually be calculated, 
        \item Priority labels for method \verb|tri_type| (when a given triangle 
        can have more than one label) is in the order right, equilateral, 
        isosceles, then scalene
        \item Input value for method \verb|tri_type| is a valid triangle (so 
        that it can be classified accordingly, as there is no option for it 
        to be of type \verb|notvalid|).
\end{itemize}

\section{Test Cases and Rationale} \label{Testing}

Tests were written such that each method that was implemented into the design
had an appropriate amount of test cases that I felt covered the edge/boundary 
cases for each method respectively. The breakdown of all test cases and 
rationale are below:

~\newline\noindent For class \verb|ComplexT|:

~\newline\noindent To test method \verb|real| and \verb|imag|, I just tested one case for each, 
as I figured it could either get the required self.variable, or it could not. 
Since these were basic methods, I did not think that there would be much variance 
in the results of it. 
~\newline\noindent To test method \verb|get_r|, I used one test case with a right angled triangle, as the absolute value of the complex number would contain a perfect square number. This was a basic case. The other case I tested was to check if the \verb|get_r| method could handle inputs which were negative and find its absolute value

~\newline\noindent To test method \verb|get_phi|,

~\newline\noindent To test method \verb|equal|,

~\newline\noindent To test method \verb|conj|,

~\newline\noindent To test method \verb|add|,

~\newline\noindent To test method \verb|sub|,

~\newline\noindent To test method \verb|mult|,

~\newline\noindent To test method \verb|recip|,

~\newline\noindent To test method \verb|div|,

~\newline\noindent To test method \verb|sqrt|,


~\newline\noindent For class \verb|TriangleT|:

~\newline\noindent To test method \verb|get_sides|,

~\newline\noindent To test method \verb|equal|,

~\newline\noindent To test method \verb|perim|, I just tested one case, as it 
was just basic addition of three positive integer numbers, which I did not think 
would give much variance in the results of different test cases. 

~\newline\noindent To test method \verb|area|,

~\newline\noindent To test method \verb|is_valid|,

~\newline\noindent To test method \verb|tri_type|,



\section{Results of Testing Partner's Code}






\section{Critique of Given Design Specification}

There were many strengths of the design specification. Firstly, the methods in the class \verb|ComplexT| well defined the aspects of a complex number, and included a variety of methods that allow the user to use the class for many different applications when dealing with complex numbers. Also, the input types for the class being of type \verb|float| is a strength it has, as it allowed a wider range of elements that can be input into the class. In terms of the methods that were implemented, most returned float values as members of a new \verb|ComplexT| object created from certain formulaic calculations, so if the type of this class was not float, and were for example integers instead, then there would need to be rounding to meet the specification, which would cause some inaccuracies in the object. For the \verb|TriangleT| class, it similarly had methods that were meant for dealing with triangles in many ways. The use of the enumerated class \verb|TriType| was also a strength to the design, that allowed the classification of the object triangle for the user from a set of different triangle types to aid the user in creating their triangle object. 

The areas of the design specification that could use improvement were in the class \verb|ComplexT|, as in its current implementation based on assumptions it does not account for the complex number being of the form z = 0 + 0i, which technically should be a part of the complex numbers in a mathematical sense. This would currently be a problem for the \verb|recip| and \verb|div| methods, as it would cause a division by zero error. This could be dealt with by adding exceptions to these methods, where it could output an error message to the user, telling them that this error would occur, and therefore that method for that particular input would be invalid. Another area that could use some improvement could be with the \verb|is_valid| method in the \verb|TriangleT| class. In the current implementation, this is used to see if the values input into the constructor for a valid triangle. Two methods in this class assume that the input forms a valid triangle in its current implementation and therefore assume that the input to the constructor is also valid, removing the need for the \verb|is_valid| method. This could have been specified by throwing an exception in these classes using this method instead, or used in the constructor class to ensure validity of the input, which would make the class function better and have less redundancy. Other improvements that could have been made to these classes is the addition of a \verb|get_quadrant| and a \verb|get_height| method for each respective class, as it would allow for more functionality of the objects, as these are important qualities to know about each class. Finally, the design specifications listed could have been less ambiguous, as it allowed for many assumptions or exceptions to be made in the design process which could have been specified more to get a clearer result. 

\section{Answers to Questions}

\begin{enumerate}[(a)]

\item Methods that are mutators are defined as methods that change the state 
of the current object, while selectors simply access the value that was set 
either by the constructor, or a mutator method. 

For both classes, there is no instance of the value of self.variable being 
changed to a new value in any method, therefore in this implementation there 
are no mutators (setters).

For the class \verb|ComplexT|, the methods that are selectors (getters) are 
\verb|real|, \verb|imag|, \verb|get_r|, \verb|get_phi|, \verb|conj|, \verb|recip|, 
and \verb|sqrt|. This is because all of these methods return a value based on the 
current state of the object they are dealing with. For example, for the 
\verb|real| method, it returns the real value of the complex object directly, 
simply reading the value of self.x and returning that. Similarly, for the 
\verb|get_r| method, it returns the absolute value of the complex number, based 
on the variables self.x and self.y. Since these directly return a variable or 
value from the state of the class, it is considered a selector. 

For the class \verb|TriangleT|, the methods that are selectors (getters) are 
\verb|get_sides|, \verb|perim| and \verb|area|. This is because it returns the 
value of the three sides that were input to the constructor (self.x, self.y 
and self.z) and does not changes the value of these terms. You could also consider
 \verb|tri_type| to be a selector, as it returns the type of triangle that the 
 constructor specified, using the variables in the enumerated class \verb|TriType|. 
 Since it returns a variable of that class, it may also be considered a selector. 

\item Two options for state variables for \verb|ComplexT| could be \verb|quadrant| 
of the complex number, and \verb|magnitude|. If using both of these as state 
variables, the user of the class could input the quadrant that the complex number 
is in, as well as its magnitude and that would create the object along with the current real and imaginary state variables. The method \verb|get_phi| would be in the correct range of values if it was given the quadrant of the complex number, as in its current implementation, it just assumes the range of the angle. The magnitude (or absolute value) would also be beneficial to have for the constructor. 

Two options for state variables for \verb|TriangleT| could be \verb|height| and \verb|hypotenuse|. These would be valid state variables as these along with the other two side lengths would allow the class to receive additional information about the triangle object that would be helpful to identify. For example, knowing which variable was the hypotenuse would greatly improve the testing for the \verb|tri_type| method, as in its current implementation, it must test all combinations of the Pythagorean theorem to test if it was a right triangle, and would improve the isosceles test case as well, as the equal sides cannot be equal to the hypotenuse. It would also be beneficial to know the height of the triangle, as this would be very useful for area calculations. 



\item The class \verb|ComplexT| has an equal method, but I do not think that 
it would make much sense to have methods for greater than or less than, as in 
this context, I am not sure how you would end up defining what range of value 
would be included in those definitions. For example, in the \verb|equal| method, 
the two complex numbers defined by the function are equal if and only if the 
real and imaginary parts are both equal respectively. If you wanted to define 
the method for greater than, you could consider the case that only the real or
 imaginary value is greater than the current object, but since the complex 
 number represents a value that has two parts to it and acts more like a vector 
 than an integer or a float (which only has 2D components), I do not think that 
 this definition would make much sense. Since the complex numbers do act like 
 vectors, you could define a greater than or less than method to work off of the 
 value of the absolute value of the number (or the magnitude), as this is a float 
 value and can easily be compared between two complex numbers, but this may not 
 reflect if the complex number is greater/less than, only that its absolute 
 value is greater/less than, which is not the same thing. Overall, if you wanted 
 to make the greater/less than methods using the same format as the current 
 implementation where the real and imaginary values of the complex number are 
 compared, then adding these methods in my opinion do not make much sense. 

 \item Since in this assignment we were asked to make a method called 
 \verb|is_valid| to check if a triangle was valid, it is very possible that the 
 three integers input to the constructor for \verb TriangleT will not form a 
 geometrically valid triangle (and that was exactly what the \verb|is_valid| 
 method was meant to check). In the case that the input is invalid, I think 
 that the class should not allow the triangle to be constructed (it should throw 
 an error as the first check in the constructor method), as it is not able to 
 actually be a fully formed triangle in the traditional sense. If the triangle 
 that was input is not valid, most of the methods included in the class do not 
 make much sense, as if it cannot physically form a triangle, it will have no 
 perimeter or area as these methods can only apply to a closed shape according 
 to their mathematical definitions and cannot be classified as a triangle in 
 the method \verb|tri_type| as it is not any of those types of triangles. In 
 my implementation, I assumed that the input would be a valid triangle for the 
 \verb|area|, so that the result could not be zero or a negative value, which 
 would not make sense for a physical triangle. I also assumed this for the 
 \verb|tri_type| method, as I did not want the result to not return the value 
 \verb|None|, as some inputs would not classify to one of the four types in the 
 class \verb|TriType|, and would therefore return that the input was of type 
 \verb|None|, which also does not make sense. For these reasons, this is what 
 I think should happen in the case that the given input is an invalid triangle.

 \item If you introduced a state variable for the type of triangle, that would require the user of the class to know what type of triangle it was when inputting values into the class. This might be a good thing, as you could then have an easy way of knowing the height of the triangle if the type was right-angled, which the user of the class might want to know, and it would negate the use of the \verb|TriType| enumerated class, and the \verb|tri_type| method, as this would be user input. However, it might be a bad thing to add, as the user might input some values for the side lengths that may not correspond to the type of triangle it actually is, which might cause some issues in the class and with the data they are using the class with, so there may need to be a check to make sure the type is  correct based on the given side lengths, but then you would need those methods that I said could be removed previously under this implementation, making the addition of this state variable redundant and unnecessary. These are some reasons why the addition of a state variable for the type of triangle might be a good or a bad idea, depending on the uses, needs and implementation of the class. 

 \item (f) relationship between software performance and usability?

 \item (g) are there situations where it is not really necessary to "fake" a rational design process?

 \item (h) how might reusability affect the reliability of products?

 \item (i) what are some examples of how programming languages are abstractions built on top of hardware?

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for complex\_adt.py}

\noindent \lstinputlisting{../src/complex_adt.py}

\newpage

\section{Code for triangle\_adt.py}

\noindent \lstinputlisting{../src/triangle_adt.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's complex\_adt.py}

\noindent \lstinputlisting{../partner/complex_adt.py}

\section{Code for Partner's triangle\_adt.py}

\noindent \lstinputlisting{../partner/triangle_adt.py}

\end {document}