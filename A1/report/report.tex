\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 1 Solution}
\author{Cassidy Baldin, baldic1}
\date{\today}

\begin {document}

\maketitle

This report discusses testing of the \verb|ComplexT| and \verb|TriangleT|
classes written for Assignment 1. It also discusses testing of the partner's
version of the two classes. The design restrictions for the assignment
are critiqued and then various related discussion questions are answered.

\section{Assumptions and Exceptions} \label{AssumptAndExcept}

No exceptions were thrown in this assignment, but some assumptions were made 
in the process of making these classes written for this assignment. These 
assumptions are made in the code where applicable, which can also be seen below as:
\begin{itemize}
        \item Input values passed to the \verb|ComplexT| constructor, were 
        assumed to be of type \verb|float|, and that both input parameters 
        would not be equal to 0 simultaneously (input will never be z = 0 + 0i),
        \item Return values of \verb|get_phi| were assumed to be in the range 
        of (-pi, pi],
        \item Input values for method \verb|equal| in class \verb|ComplexT| is 
        of type \verb|ComplexT|, and values are considered to be equal if both 
        the real and imaginary values of the argument are equal to the current 
        real and imaginary values respectively (within 9 decimal places),
        \item Return value of \verb|conj|, \verb|add|, \verb|sub|, \verb|mult|, 
        \verb|recip|, \verb|div| and \verb|sqrt| is a new ComplexT that is 
        equal to the result of their respective methods,
        \item Return value of \verb|sqrt| is only the positive part of the square 
        root of the current object, 
        \item Input values passed to the \verb|TriangleT| constructor, were 
        assumed to be positive, non-zero integer values (to relate to the real 
        world application of triangle dimensions),
        \item Input values for method \verb|equal| in class \verb|TriangleT| is 
        of type \verb|TriangleT|, and values are considered to be equal all side 
        lengths are equal (within 9 decimal places),
        \item Input value for method \verb|area| is a valid triangle so that the 
        area can actually be calculated, 
        \item Priority labels for method \verb|tri_type| (when a given triangle 
        can have more than one label) is in the order right, equilateral, 
        isosceles, then scalene
        \item Input value for method \verb|tri_type| is a valid triangle (so 
        that it can be classified accordingly, as there is no option for it 
        to be of type \verb|notvalid|).
\end{itemize}

\section{Test Cases and Rationale} \label{Testing}

Tests were written such that each method that was implemented into the design
had an appropriate amount of test cases that I felt covered the edge/boundary 
cases for each method respectively. The breakdown of all test cases and 
rationale are below:

~\newline\noindent For class \verb|ComplexT|:

~\newline\noindent To test method \verb|real| and \verb|imag|, I tested one 
case for each, as I thought it would either get the required self.variable, 
or it would not. Since these were basic methods, I did not think that there 
would be much variance in the results of it. 
~\newline\noindent To test method \verb|get_r|, I tested one case with a right 
angled triangle, as the absolute value of the complex number would contain a 
perfect square number. This was a basic case. The other case I tested was to 
check if the \verb|get_r| method could handle inputs which were negative and 
find its absolute value. 
~\newline\noindent To test method \verb|get_phi|, I used three cases, one with 
both positive inputs, one with a negative imaginary value, and one with a negative 
real value and imaginary value equal to 0. This was to check if the basic case 
and when one was a negative value. I used \verb|math.isclose()| to check if the 
values of the test were within 9 decimal places of the expected answer, as that 
is the amount of digits the result is on the Casio calculator used by McMaster 
students that I used to get my expected answers using the formula described in 
this method. I figured it was a good base for the accuracy of the python program 
result. In hindsight while writing this summary, I should have added another case 
for when the input is a negative real value and the imaginary value equal to zero 
to test both parts of the if statement were working correctly. 
~\newline\noindent To test method \verb|equal|, I tested five cases, the first 
two were to check if it was working correctly in the basic cases. The third and 
fourth case were to test float rounding errors and used \verb|math.isclose()| to 
check if the numbers were still equal even if they were rounded or approximate. 
The last test was to check float precision errors to check if the original code 
accounted for close values to be accepted as equal or not (my implementation did 
this).
~\newline\noindent To test method \verb|conj|, I tested two cases, one where the 
imaginary value was originally positive, and the other where the imaginary value 
was originally negative. This was a basic function that simply multiplied one 
term by negative one, so I did not think there would be varied results. 
~\newline\noindent To test method \verb|add|, I tested two test cases, one where 
there was a negative imaginary value, and one where there was a negative real 
value. These were basic cases, as I did not think that addition would cause much 
variance in the results. 
~\newline\noindent To test method \verb|sub|, I tested two cases, one where there 
was a negative imaginary value, and one where there was a negative real value. 
These were basic cases, as I did not think that subtraction would cause much 
variance in the results. 
~\newline\noindent To test method \verb|mult|, I tested four cases, with the 
first two multiplying the positive complex number by one with a negative real 
value, and the other with a negative imaginary number. The other two cases were 
to test the result when the real value was 0, and when the imaginary value was zero. 
~\newline\noindent To test method \verb|recip|, I tested four cases, with the 
first two finding the reciprocal when the positive complex number by one with 
a negative real value, and the other with a negative imaginary number. The other 
two cases were to test the result when the real value was 0, and when the imaginary value was zero. 
~\newline\noindent To test method \verb|div|, I tested four cases, with the first 
two dividing the positive complex number by one with a negative real value, and 
the other with a negative imaginary number. The other two cases were to test the 
result when the real value was 0, and when the imaginary value was zero. 
~\newline\noindent To test method \verb|sqrt|, I tested four cases, with the first 
one being a basic case. Then I added cases to test both if statements by making 
one case with the imaginary value equal to zero, and one case where the imaginary 
value was negative. The last case was testing the square root when the real value 
was negative. 

~\newline\noindent For class \verb|TriangleT|:

~\newline\noindent To test method \verb|get_sides|, I tested one case, as I thought 
it would either returned the input values as a tuple, or it would not. Since this 
were basic methods, I did not think that there would be much variance in the results 
of it. 
~\newline\noindent To test method \verb|equal|, I tested three cases, first testing 
if the true case would be returned when the values of the triangle were equal but 
not in the same order. Then I tested the false cases by checking if it false would 
be returned when two of the values were the same, but not the third in different 
orders. Since these numbers were integers, I did not need to test the method 
against float errors like in the \verb|ComplexT| class. 
~\newline\noindent To test method \verb|perim|, I tested one case, as it was just 
basic addition of three positive integer numbers, which I did not think would 
give much variance in the results of different test cases. 
~\newline\noindent To test method \verb|area|, I tested two cases, with the first 
being a basic case with a right angled triangle. For the second since it was 
expected to return a float value, I used \verb|math.isclose()| to 9 decimal 
places like in the \verb|ComplexT| class. 
~\newline\noindent To test method \verb|is_valid|, I tested three cases, with 
two cases that were true, and one that I knew was false. This was to test the 
different brackets in the if statement of this method. 
~\newline\noindent To test method \verb|tri_type|, I tested three cases, with 
the first one checking the right triangle priority over scalene, and the second 
to make sure it was not marked as isosceles. The third test was to check if the 
fourth triangle was isosceles as it should be. 

~\newline\noindent I automated my test cases, tallying the amount of passed 
versus failed cases and printing them to the console when the testing was 
finished to let the tester know the results, as well as which failed if any. 

\section{Results of Testing Partner's Code}

I ran my partner's files against my own testing document, and my testing document 
failed to fully run. I realized that they had spelled "isosceles" wrong in their 
\verb|tri_type| method and \verb|TriType| enumerated class and that was causing 
the error. Once I fixed this, they got a score of 25/34 for the \verb|ComplexT| 
class and 9/13 for the \verb|TriangleT| class. They had failed all of the 
\verb|mult| method tests, so I looked at how they implemented their method 
compared to mine, and noticed that they had used the term \verb|self.real()| 
when I used the argument's real component. After looking at the formula again, 
I think this may have been another mistake on my partner's end so I changed their 
code to the correct formula by changing that term to \verb|num.mult.real()| to 
match with their naming conventions. This updated their score to 29/34 for the 
\verb|ComplexT| class. 
~\newline\noindent One of the tests they failed was the precision of floating 
numbers test, where the input had a real component of 0.3 + 0.3 + 0.3. This would 
equate to a value of 0.899999... as there is an error with floating point numbers 
when being added. This test was to test if they had accounted for slight floating 
point errors in their equal method, as I had accounted for this in my own code. 
~\newline\noindent The next case they had failed was the second division case, 
where it tested the division of the positive complex number by one with a negative 
real value. This returned a fail value, even though their result was within 9 
decimal places of the expected answer. I then realized this was because of their 
equals method like I explained earlier, as it did not account for floating point 
precision errors, while I based by checks off of the equals method working for 
cases like that. I should have used the \verb|math.isclose)()| function to test 
the real and the imaginary values respectively so that this error did not occur 
while testing. This was also the case for the \verb|sqrt| method, however, the 
second test of this method would return a failed test regardless, as the value 
of the imaginary was not negative when it should have been according to the 
expected output. 

~\newline\noindent When checking the \verb|TriangleT| class tests, the first one 
they failed was for the method \verb|get_sides|. This was because they returned 
the side lengths in an list instead of a tuple as was specified in the design 
specifications.
~\newline\noindent The next case they failed were both the area tests. I thought 
it would be for the same reason as the equal test, but upon printing out the 
values, both of their test cases were far off from the expected result. After 
looking at their formula, I noticed that they did not divide the perimeter by 
2 when using this formula which was causing the error in the calculation. 
~\newline\noindent The last test they failed was the third \verb|tri_type| test, 
which tested if the object TriangleT(3, 4, 3) returned the type 
\verb|TriType.isosceles| as two of its sides were the same length. However, it 
returned a classification of \verb|TriType.right|. This was because to calculate 
their right triangle requirements, they used the \verb|round| function which 
rounded the value of $\sqrt{3^{2} + 3^{2}}$ to 4, meaning that the result was a triangle that seemed to be right angled when it was not. 

~\newline\noindent These were the results of the test cases on my partner files. 
When going through their code, I realized that I did not add many edge cases to 
my tests, as my code assumed they would never be input values while my partner 
did have those edge cases in their class. This was something to think about as 
it would probably make for a more robust program that does not solely rely on 
the user to not input the wrong type of data into the class. 

\section{Critique of Given Design Specification}

There were many strengths of the design specification. Firstly, the methods in 
the class \verb|ComplexT| well defined the aspects of a complex number, and 
included a variety of methods that allow the user to use the class for many 
different applications when dealing with complex numbers. Also, the input types 
for the class being of type \verb|float| is a strength it has, as it allowed a 
wider range of elements that can be input into the class. In terms of the methods 
that were implemented, most returned float values as members of a new 
\verb|ComplexT| object created from certain formulaic calculations, so if the 
type of this class was not float, and were for example integers instead, then 
there would need to be rounding to meet the specification, which would cause 
some inaccuracies in the object. For the \verb|TriangleT| class, it similarly 
had methods that were meant for dealing with triangles in many ways. The use of 
the enumerated class \verb|TriType| was also a strength to the design, that 
allowed the classification of the object triangle for the user from a set of 
different triangle types to aid the user in creating their triangle object. 

The areas of the design specification that could use improvement were in the 
class \verb|ComplexT|, as in its current implementation based on assumptions 
it does not account for the complex number being of the form z = 0 + 0i, which 
technically should be a part of the complex numbers in a mathematical sense. 
This would currently be a problem for the \verb|recip| and \verb|div| methods, 
as it would cause a division by zero error. This could be dealt with by adding 
exceptions to these methods, where it could output an error message to the user, 
telling them that this error would occur, and therefore that method for that 
particular input would be invalid. Another area that could use some improvement 
could be with the \verb|is_valid| method in the \verb|TriangleT| class. In the 
current implementation, this is used to see if the values input into the 
constructor for a valid triangle. Two methods in this class assume that the input 
forms a valid triangle in its current implementation and therefore assume that 
the input to the constructor is also valid, removing the need for the 
\verb|is_valid| method. This could have been specified by throwing an exception 
in these classes using this method instead, or used in the constructor class to 
ensure validity of the input, which would make the class function better and have 
less redundancy. Other improvements that could have been made to these classes 
is the addition of a \verb|get_quadrant| and a \verb|get_height| method for each 
respective class, as it would allow for more functionality of the objects, as 
these are important qualities to know about each class. Finally, the design 
specifications listed could have been less ambiguous, as it allowed for many 
assumptions or exceptions to be made in the design process which could have been 
specified more to get a clearer result. 

\section{Answers to Questions}

\begin{enumerate}[(a)]

\item Methods that are mutators are defined as methods that change the state 
of the current object, while selectors simply access the value that was set 
either by the constructor, or a mutator method. 

For both classes, there is no instance of the value of self.variable being 
changed to a new value in any method, therefore in this implementation there 
are no mutators (setters).

For the class \verb|ComplexT|, the methods that are selectors (getters) are 
\verb|real|, \verb|imag|, \verb|get_r|, \verb|get_phi|, \verb|conj|, \verb|recip|, 
and \verb|sqrt|. This is because all of these methods return a value based on the 
current state of the object they are dealing with. For example, for the 
\verb|real| method, it returns the real value of the complex object directly, 
simply reading the value of self.x and returning that. Similarly, for the 
\verb|get_r| method, it returns the absolute value of the complex number, based 
on the variables self.x and self.y. Since these directly return a variable or 
value from the state of the class, it is considered a selector. 

For the class \verb|TriangleT|, the methods that are selectors (getters) are 
\verb|get_sides|, \verb|perim| and \verb|area|. This is because it returns the 
value of the three sides that were input to the constructor (self.x, self.y 
and self.z) and does not changes the value of these terms. You could also consider
 \verb|tri_type| to be a selector, as it returns the type of triangle that the 
 constructor specified, using the variables in the enumerated class \verb|TriType|. 
 Since it returns a variable of that class, it may also be considered a selector. 

\item Two options for state variables for \verb|ComplexT| could be \verb|quadrant| 
of the complex number, and \verb|magnitude|. If using both of these as state 
variables, the user of the class could input the quadrant that the complex number 
is in, as well as its magnitude and that would create the object along with the 
current real and imaginary state variables. The method \verb|get_phi| would be in 
the correct range of values if it was given the quadrant of the complex number, as 
in its current implementation, it just assumes the range of the angle. The magnitude 
(or absolute value) would also be beneficial to have for the constructor. 

Two options for state variables for \verb|TriangleT| could be \verb|height| and 
\verb|hypotenuse|. These would be valid state variables as these along with the 
other two side lengths would allow the class to receive additional information 
about the triangle object that would be helpful to identify. For example, knowing 
which variable was the hypotenuse would greatly improve the testing for the 
\verb|tri_type| method, as in its current implementation, it must test all 
combinations of the Pythagorean theorem to test if it was a right triangle, and 
would improve the isosceles test case as well, as the equal sides cannot be equal 
to the hypotenuse. It would also be beneficial to know the height of the triangle, 
as this would be very useful for area calculations. 

\item The class \verb|ComplexT| has an equal method, but I do not think that 
it would make much sense to have methods for greater than or less than, as in 
this context, I am not sure how you would end up defining what range of value 
would be included in those definitions. For example, in the \verb|equal| method, 
the two complex numbers defined by the function are equal if and only if the 
real and imaginary parts are both equal respectively. If you wanted to define 
the method for greater than, you could consider the case that only the real or
imaginary value is greater than the current object, but since the complex 
number represents a value that has two parts to it and acts more like a vector 
than an integer or a float (which only has 2D components), I do not think that 
this definition would make much sense. Since the complex numbers do act like 
vectors, you could define a greater than or less than method to work off of the 
value of the absolute value of the number (or the magnitude), as this is a float 
value and can easily be compared between two complex numbers, but this may not 
reflect if the complex number is greater/less than, only that its absolute 
value is greater/less than, which is not the same thing. Overall, if you wanted 
to make the greater/less than methods using the same format as the current 
implementation where the real and imaginary values of the complex number are 
compared, then adding these methods in my opinion do not make much sense. 
 
\item Since in this assignment we were asked to make a method called 
\verb|is_valid| to check if a triangle was valid, it is very possible that the 
three integers input to the constructor for \verb TriangleT will not form a 
geometrically valid triangle (and that was exactly what the \verb|is_valid| 
method was meant to check). In the case that the input is invalid, I think 
that the class should not allow the triangle to be constructed (it should throw 
an error as the first check in the constructor method), as it is not able to 
actually be a fully formed triangle in the traditional sense. If the triangle 
that was input is not valid, most of the methods included in the class do not 
make much sense, as if it cannot physically form a triangle, it will have no 
perimeter or area as these methods can only apply to a closed shape according 
to their mathematical definitions and cannot be classified as a triangle in 
the method \verb|tri_type| as it is not any of those types of triangles. In 
my implementation, I assumed that the input would be a valid triangle for the 
\verb|area|, so that the result could not be zero or a negative value, which 
would not make sense for a physical triangle. I also assumed this for the 
\verb|tri_type| method, as I did not want the result to return the value 
\verb|None|, as some inputs would not classify to one of the four types in the 
class \verb|TriType|, and would therefore return that the input was of type 
\verb|None|, which also does not make sense. For these reasons, this is what 
I think should happen in the case that the given input is an invalid triangle.

\item If you introduced a state variable for the type of triangle, that would 
require the user of the class to know what type of triangle it was when inputting 
values into the class. This might be a good thing, as you could then have an 
easy way of knowing the height of the triangle if the type was right-angled, 
which the user of the class might want to know, and it would negate the use 
of the \verb|TriType| enumerated class, and the \verb|tri_type| method, as this 
would be user input. However, it might be a bad thing to add, as the user might 
input some values for the side lengths that may not correspond to the type of 
triangle it actually is, which might cause some issues in the class and with 
the data they are using the class with, so there may need to be a check to make 
sure the type is  correct based on the given side lengths, but then you would 
need those methods that I said could be removed previously under this 
implementation, making the addition of this state variable redundant and 
unnecessary. These are some reasons why the addition of a state variable for 
the type of triangle might be a good or a bad idea, depending on the uses, 
needs and implementation of the class. 

\item The relation between the software qualities of performance and usability is 
the better it performs, the more likely it is to be used much more frequently. 
Performance is related to external quality requirements for speed and storage 
and is usually compared to existing products. Usability refers to the ease at 
which a typical human user can use the product. If a software product is used 
often, this usually means it performs well and is helpful to the user of the 
product (meaning that greater performance usually equates to greater usability). 
If this was not the case, the user would likely move on to a different product 
that would indeed perform better to suit the users needs. This is why poor 
performance often adversely affects the usability and scalability of the product. 
Therefore, the relation between software performance and usability are proportional 
to each other, in which when one is high in quality, so is the other. Some 
information was taken from lecture slide set L04. 

\item The rational design process consists of steps that include a problem 
statement, development plan, requirements (SRS), design docs (MG and MIS), 
code and a V \& V Report. Usually this process is faked, as the requirements 
for the design are usually not known in its entirety at the start of a project, 
making this process less of a "waterfall" and more of a work in progress. It 
is usually not as straight forward as this process suggests. However, there 
are some situations where it is not really necessary to "fake" a rational design 
process like this assignment, where the specifications were given in detail at 
the start, were not very subject to change, and the students were expected to 
follow steps in a certain order by a certain time. In these circumstances, the 
design process did not have to be faked, as it generally was a linear process, 
where we were given specifications that we not changed, wrote the code, the 
report, and did not go back and forth between stages as there were set due 
dates. This was not faked and instead generally followed the structure outlined 
in the rational design process. Also, when doing your own personal projects, 
the structure need not be to a professional degree of documentation and these 
steps do not need to be stated in the particular order as the rational design 
process suggests. When doing your own projects, you should still be documenting 
as you go, but it does not need to be setup in this manner, meaning it does not 
have to necessarily be faked. These are some situations where it is not really 
necessary to "fake" a rational design process. Some information taken from lecture 
slide set L03. 
 
\item The reusability of a product might affect its reliability as the more times 
a product is used, the more likely it is to cause wear and other malfunctions 
to occur as a result. For example, a plastic bag can be reused many times over, 
but each time it is used may lead to more damage to the bag until it eventually 
breaks and cannot be used anymore. This analogy is similar to the reusability 
of a software product, in which if designed to be used multiple times and in 
different ways, it may break down over time, whether it be the fault of the 
user, or the software itself. This reusable approach is helpful when designing 
software to last over long periods of time and stay current, but in order to 
continue to stay reliable and do what it is intended to do, it must be kept 
up to date and any bugs or problems with it must be addressed regularly. Also, 
the longer a product is used may cause the product to fall behind and not evolve 
with the ever changing world ahead of it. In order for software to improve and be 
kept current, it must be maintained accordingly. This is how the reusability of a 
product might affect its reliability. 

\item (i) what are some examples of how programming languages are abstractions built on top of hardware?

Some examples of how programming languages are abstractions built on top of hardware  can be seen in different languages like Python or Java, where users can write instructions in a more human-like language that is easier for them to understand. Then the program converts it to a list of commands that the hardware can actually understand, allowing it to actually execute what the user wanted.



\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for complex\_adt.py}

\noindent \lstinputlisting{../src/complex_adt.py}

\newpage

\section{Code for triangle\_adt.py}

\noindent \lstinputlisting{../src/triangle_adt.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's complex\_adt.py}

\noindent \lstinputlisting{../partner/complex_adt.py}

\section{Code for Partner's triangle\_adt.py}

\noindent \lstinputlisting{../partner/triangle_adt.py}

\end {document}